Этимология
Происходит от слова «зомби», означающего «живой мертвец» (оксюморон, англ. undead). Термин является яркой метафорой о том, что процесс «умер», но не «погребён».

Возникновение зомби
Процесс при завершении (как нормальном, так и в результате не обрабатываемого сигнала) освобождает все свои ресурсы и становится «зомби» — пустой записью в таблице процессов, хранящей статус завершения, предназначенный для чтения родительским процессом.
Зомби-процесс существует до тех пор, пока родительский процесс не прочитает его статус с помощью системного вызова wait(), в результате чего запись в таблице процессов будет освобождена.
При завершении процесса система уведомляет родительский процесс о завершении дочернего с помощью сигнала SIGCHLD, таким образом может быть удобно (но не обязательно) осуществлять вызов wait() в обработчике данного сигнала.

Проблемы зомби
Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор sh должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.
Иногда, если родительский процесс выполняется от имени суперпользователя, для освобождения записей (перезапуска процесса) может потребоваться перезагрузка (причём зачастую — только аппаратным рестартом). Некоторые операционные системы (например, Sun Solaris) при возникновении такой ситуации аварийно завершают часть выполняющихся процессов, восстанавливая работоспособность системы.
Всякий процесс при завершении и до считывания статуса завершения предком пребывает в состоянии зомби, это совершенно нормально и короткоживущие зомби-процессы не представляют проблемы в системе. При этом ряд ошибок программирования может приводить к возникновению и накоплению в системе необрабатываемых процессов-зомби (т. е. уже завершившихся процессов, родитель которых не считывает их статус).
Игнорирование обработки завершения дочерних процессов не является правильным, но обычно не приводит к проблемам для короткоживущих программ, так как при завершении процесса все его потомки становятся потомками процесса init, который постоянно считывает статус своих потомков-зомби, очищая таблицу процессов. Именно для задействования этого механизма выполняется стандартная техника запуска демонов "double fork()": промежуточный родитель завершается, делая родителем своего потомка процесс init .
Для долгоживущих и часто создающих дочерние процессы программ, необходима корректная обработка контроля завершения дочерних программ, потому что накапливание необрабатываемых зомби приводит к «утечке ресурсов» в виде накопления записей в таблице процессов.
В linux, начиная с версии kernel 3.4, процесс имеет возможность объявить себя усыновителем сирот ("subreaper") вместо процесса init командой prctl(PR_SET_CHILD_SUBREAPER).


Разное
Зомби не могут принимать сигналы, и поэтому их нельзя убрать с помощью утилиты или вызова kill. Убрать их может либо родительский процесс, либо его завершение.
Все процессы в Unix имеют своих родителей — процессы, не имеющие или потерявшие родителей («осиротевшие» процессы; англ. orphan process), являются дочерними для init (процесс с PID = 1), который, в свою очередь, является дочерним для ядра (процесса с PID = 0). init всегда обрабатывает SIGCHLD, поэтому от таких процессов никогда не остаётся зомби.
Зомби можно узнать в списке процессов (выводимых утилитой ps) по флагу «Z» в колонке STAT.
Хорошим стилем программирования считается всегда обрабатывать SIGCHLD.
Языки скриптов Perl и Python неявно обрабатывают SIGCHLD, если программа настраивает его игнорирование.

Примеры программ, создающих зомби
#!/usr/bin/env python2
# -*- coding: utf8 -*-

import subprocess
import time
import threading

# Порождаем процесс 'ls' с параметром '-l'
proc = subprocess.Popen(['ls','-l'])

# Останавливаем главный поток программы на 5 секунд. На их протяжении процесс будет иметь
# статус "зомби", хоть процесс уже и завершился, поскольку не была выполнена обработка
# результата процесса
time.sleep(5)

# В этом месте зомби исчезнет, т.к. программа очистит буферы ввода-вывода для процесса
# и считает код его завершения
proc.communicate()

time.sleep(5)


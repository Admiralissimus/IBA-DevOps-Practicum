top (table of processes) — консольная команда, которая выводит список работающих в системе процессов и информацию о них. По умолчанию она в реальном времени сортирует их по нагрузке на процессор. Программа написана для UNIX-совместимых операционных систем и опубликована под свободной лицензией GNU FDL.

https://habr.com/ru/companies/host-tracker/articles/220413/

top - 00:34:45 up  2:24,  1 user,  load average: 0.47, 0.30, 0.28
Tasks: 210 total,   1 running, 209 sleeping,   0 stopped,   0 zombie
%Cpu(s):  6.4 us,  2.1 sy,  0.0 ni, 91.4 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
MiB Mem :   2908.2 total,    116.5 free,   1229.8 used,   1562.0 buff/cache
MiB Swap:   5046.0 total,   5043.5 free,      2.5 used.   1419.9 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                      
   1429 alex      20   0  399788  11832   7116 S   0.6   0.4   0:01.91 ibus-daemon                                                  
    473 systemd+  20   0   14824   6296   5500 S   0.3   0.2   0:27.68 systemd-oomd                                                 
   1732 alex      20   0  230048   2344   1984 S   0.3   0.1   0:23.53 VBoxClient                                                   
   4352 root      20   0       0      0      0 I   0.3   0.0   0:01.25 kworker/1:1-ata_sff                                          
   7539 alex      20   0   32.3g  90764  69180 S   0.3   3.0   0:54.83 code                                                         
   7560 alex      20   0   54.5g 250264 133152 S   0.3   8.4   2:12.90 code                                                         
   7591 alex      20   0   44.5g 135768  99900 S   0.3   4.6   0:08.49 code                                                         
   7603 alex      20   0   36.4g 109236  62836 S   0.3   3.7   0:05.91 code                                                         
   7615 alex      20   0   36.4g  81708  59916 S   0.3   2.7   0:07.47 code                                                         
      1 root      20   0  101228  11992   8364 S   0.0   0.4   0:02.16 systemd                                                      
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd                                                     
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                       
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par

Программа с частотой обновления в 2с показывает текущую активность процессов в виде таблицы. Стандартные колонки:

PID — идентификатор процесса
USERNAME — пользователь, от которого запущен процесс
THR — количество потоков, запущенных процессом
PR — текущий приоритет процесса
NICE — приоритет, выставленный командой nice. От −20 (наивысший) до 19.
SIZE — размер процесса (данные, стек и т. д.) в килобайтах
RES — текущее использование оперативной памяти
STATE — текущее состояние («START», «RUN» (только в этом состоянии показывает текущую нагрузку программы на процессор), «SLEEP», «STOP», «ZOMB», «WAIT» или «LOCK»)
C — номер процессора, на котором идет выполнение (доступен только на SMP системах)
TIME — время использования процессора в секундах
VIRT — полный объем виртуальной памяти, которую занимает процесс
%CPU — процент доступного времени процессора, которое использовала запущенная программа
%MEM — процент использования оперативной памяти данным процессом
WCPU — усредненное значение CPU
COMMAND — команда, запустившая процесс.

MiB Mem: xxx total - это общий объем физической памяти (RAM) в системе, измеренный в мебибайтах (MiB).
MiB Mem: xxx free - это объем свободной памяти, которая не используется ни одним процессом, измеренный в мебибайтах (MiB).
MiB Mem: xxx used - это объем памяти, который используется процессами, измеренный в мебибайтах (MiB).
MiB Mem: xxx buff/cache - это объем памяти, который используется для буферов и кэша ядра, измеренный в мебибайтах (MiB). Буферы и кэш служат для ускорения доступа к данным на диске или сети. Эта память может быть освобождена при необходимости .
MiB Swap: xxx total - это общий объем своп-пространства в системе, измеренный в мебибайтах (MiB). Своп-пространство - это часть диска, которая используется для временного хранения страниц памяти, которые не помещаются в физическую память .
MiB Swap: xxx free - это объем свободного своп-пространства в системе, измеренный в мебибайтах (MiB).
MiB Swap: xxx used - это объем использованного своп-пространства в системе, измеренный в мебибайтах (MiB).
MiB Swap: xxx avail Mem - это объем доступной памяти в системе, измеренный в мебибайтах (MiB). Это сумма свободной памяти и буферов/кэша.

Давайте разберем значение каждой из строк.

top – 17:15:19 up 32 days, 18:24, 6 users
Здесь показана команда и текущее системное время; «время бесперебойной работы», в нашем случае это 32 дня, 18 часов и 24 минуты; наконец, указывается количество зарегистрированных в системе пользователей; в данном примере, в системе зарегистрированы 6 пользователей. Они могут быть подключены по SSH, локально, быть неактивными и т.д.

load average: 0,00, 0,01, 0,05
В этой части показывается средняя нагрузка; она может сбивать с толку, особенно на виртуальной машине/в облаке.
Первая цифра показывает среднюю нагрузку «последней минуты», или «текущую» среднюю нагрузку; вторая цифра показывает «среднюю нагрузку за 5 минут», последняя цифра – «среднюю нагрузку за 15 минут».
Средняя нагрузка – мера среднего числа процессов, ожидающих своей очереди, чтобы совершить какое-либо действие в процессоре. Как и в супермаркете, приходится стоять в очереди, дожидаясь, пока кассир уделит вам все свое внимание. Причина, по которой средняя нагрузка растет, заключается в остальной статистике и счетчиках, находящихся ниже этой линии, поэтому, если ориентироваться строго на значения средней нагрузки, можно не увидеть всей картинки полностью.

Вот пример, взятый из узла distcc:

Данный сервер, кроме того, что является средой промежуточной обработки для скриптов и хостингом инструментов командной строки облака, предоставляет также распределенную службу C компилятора различным машинам, находящимся в нашей сети, поскольку она имеет 8 процессоров, 32 ГБ оперативной памяти и тонну псевдодискового пространства. При нормальной нагрузке, среднее ее значение остается относительно низким; при выполнении java-скриптов нагрузка может вырастать в два и более раза. Однако при выполнении службы компилятора при полной нагрузке (10 выполняемых процессов при загрузке процессора, равной 95% или выше), среднее значение нагрузки составляет 0,75… Как же так получается? Попытаемся разобраться

Строка Tasks

Tasks: 119 total, 1 running, 118 sleeping, 0 stopped, 0 zombie
Tasks: показывает количество процессов, когда вы набираете, например, “ps aux”.
• total Общее количество задач полезно знать для выявления вышедшего из-под контроля сервера apache или экземпляра postgresql, но оно обычно остается достаточно стабильным.
• running Количество запущенных процессов показывает вам, как в настоящее время используется ваш процессор. Приложения, не имеющие многопоточности, за один раз, как правило, могут использовать 1 процессор, поэтому обычным делом является ситуация, когда 1 процесс использует 25% процессора четырехъядерного сервера со средней нагрузкой ~1.
• sleeping Количество ждущих процессов показывает, какие процессы выполняются, но не являются активными; обычно это фоновые задачи, системное ПО, драйвера принтера и т.д.
• stopped Количество остановленных процессов должно, как правило, равняться 0, если вы не послали процессу сигнал a SIGSTOP или kill -STOP для устранения неисправностей. Если это число отличается от 0, то, в случае с рабочими серверами это может служить поводом для беспокойства.
• zombie Зависшие процессы. Это означает, что многопоточное приложение запустило дочерний процесс, а затем было уничтожено или неожиданно завершено, оставив после себя повисший процесс, известный, как zombie-процесс. Apache может наплодить целую кучу таких процессов в случае, если происходит что-то из ряда вон выходящее. Обычно, их число тоже должно равняться 0.

Строка Cpu

Я разобью эту информацию на две части, в них содержится статистика, важная для нашего использования.

Cpu(s): 0.0%us, 0.0%sy, 0.0%ni, 99.9%id,
Первые четыре величины, приведенные здесь, присутствуют на всех серверах с linux, и они привычны для большинства людей.
• %us показывает использование отдельного процессора (пользовательскими процессами, такими, как apache, mysql и т.д.) до максимального значения, составляющего 100%. Таким образом, если в четырехъядерном процессоре 1 процесс использует 100% CPU, это даст значение %us, равное 25%. Значение 12,5% для 8-ядерного процессора означает, что занято одно ядро.
• %sy означает использование CPU системой. Обычно это значение невысоко, высокие его значения могут свидетельствовать о проблеме с конфигами ядра, проблему со стороны драйвера, или целый ряд других вещей.
• %ni означает процент CPU, используемого пользовательскими процессами, на которые повлияло использование команд nice или renice, т.е. по существу их приоритет был изменен по сравнению с приоритетом по умолчанию, назначаемому планировщиком, на более высокий или низкий. При назначении какому-либо процессу команды nice, положительное число означает более низкий приоритет (1 = 1 шаг ниже нормального), а отрицательное число означает более высокий приоритет. 0 – значение по умолчанию, что означает, что решение о приоритете принимает планировщик. Можно установить, какой планировщик используется вашей системой, но это более сложная тема для следующих статей. Кроме того, любая величина в процентах, приведенная в этот статье не накладывается на величину %us, которая показывает только пользовательские процессы с невыставленным приоритетом.
• %id – результат, получающийся при вычитании трех предыдущих значений из 100,0%, и измеряющий «простаивающую» вычислительную мощность.

0.0%wa, 0.0%hi, 0.0%si, 0.0%st
Второй набор значений связан с виртуализацией, и именно по ним мы можем точно отследить те проблемы, которые, возможно, вносят вклад в высокое значение средней нагрузки.

• %wa – iowait, процент времени (циклов, секунд), в течение которого процессор простаивал, ожидая завершения операции ввода-вывода. Когда какой-либо процесс или программа запрашивает данные, он сначала проверяет кэш процессора (в нем имеется 2 или 3 кэша), затем проверяет память и, наконец, доходит до диска. Дойдя до диска, процессу или программе обычно приходится ждать, пока поток ввода-вывода передаст информацию в оперативную память, прежде чем иметь возможность снова на нем работать. Чем медленнее диск, тем выше будет значение IO Wait % для каждого процесса. Это происходит также с процессами записи на диск, если системный буфер заполнен и его необходимо прочистить при помощи ядра – обычно это наблюдается на серверах баз данных с высокой нагрузкой. Если значение IO Wait стабильно превышает {100 / (кол-во CPU * кол-во процессов)}%, это означает, что, возможно, имеется проблема хранения, с которой необходимо разобраться. Если вы наблюдаете высокую среднюю нагрузку, прежде всего, проверьте этот параметр. Если он высок, тогда узкое место в процессах, скапливающихся на диске, а не в чем-либо еще.
• %hi означает прерывания на уровне железа; на плате электроны движутся по микросхемам предсказуемым образом. Например, когда сетевая карта получает пакет, перед передачей информации, содержащейся в пакете в процессор через ядро, она запросит прерывание в канале прерывания материнской платы. Процессор сообщает ядру, что у сетевой карты для него есть информация, а ядро имеет возможность решить, как поступить. Высокое значение времени, тратящегося на обработку прерываний на уровне железа встречается на виртуальной машине довольно редко, но по мере того, как гипервизоры предоставляют в распоряжение виртуальных машин все больше «железа», эта ситуация может измениться. Чрезвычайно высокая пропускная способность сети, использование USB, вычисления на графических процессорах, — все это может привести к росту этого параметра на величину, превышающую несколько процентов.
• %si – прерывание на уровне софта; в ядре linux версии 2.4 реализована возможность запроса прерывания программным обеспечением (приложениями), а не элементом аппаратного обеспечения или устройством (драйвером), запрашивающим прерывание в канале прерывания материнской платы; запрос обслуживается ядром посредством его обработчика прерываний. Это означает, что приложение может запросить приоритетный статус, ядро может подтвердить получение команда, а программное обеспечение будет терпеливо ждать, пока прерывание не будет обслужено. Если мы применим утилиту tcpdump к гигабитному каналу с высоким трафиком, то значение может измениться примерно на 10%, — по мере заполнения выделенной памяти tcpdump, утилита посылает зарос на прерывание, чтобы переместить данные со стека на диск, экран, или куда угодно еще.
• %st — самый важный параметр из всех в списке, по моему мнению, это IOSteal%. В виртуализированной среде множество логических серверов могут работать под одним фактическим гипервизором. Каждой виртуальной машине(VM) мы присваиваем 4-8 «виртуальных» CPU; хотя сами гипервизоры могут не иметь (кол-во VM * кол-во виртуальных CPU на одну VM). Причина этого заключается в том, что мы не перегружаем CPU использованием наших виртуальных машин, так что если мы дадим одной-двум VM возможность изредка использовать 8 процессоров, это не будет негативно влиять на весь пул в целом. Однако если виртуальными процессорами VM используется количество CPU, превышающее количество физических (или логических, в случае с гиперпотоковыми процессорами Xeon), тогда значение iosteal будет расти.

iosteal% — мера загруженности гипервизора; наличие в каком-либо пуле виртуальных машин, демонстрирующих стабильно высокое значение параметра iosteal% (более 15%) может свидетельствовать о необходимости переноса некоторых из VM в другую часть пула.

iowait% является показателем производительности диска. В системе хранения данных, поддерживаемой NetApp, у нас может не получиться решить проблему производительности без перемещения тома на менее используемый, или другой диск NetApp. В случае с локальным диском (SSD или SAS) это может означать, что в гипервизоре имеется слишком много VM, интенсивно использующих ресурсы диска, и может потребоваться перенести некоторые из этих VM в другую часть пула.

Подведем итоги:

• Средняя нагрузка, на самом деле, ни о чем не говорит.
• Параметр %userland (%us) важен для средней нагрузки, поскольку он говорит о том, что производятся вычисления. Например, mysql, займет всего один поток, поэтому при полной нагрузке будет использовать (1/кол-во виртуальных CPU, присвоенных VM). postgresql является многопоточным, и может использовать больше процессоров, если они будут выделены, – помните об этом, создавая виртуальные машины в гипервизоре, чтобы предотвратить:
• %st – iosteal% — показатель загруженности гипервизора. Создание стека из 4-х postgresql и 6 серверов tomcat под одним гипервизором может быть разумным с точки зрения бизнеса, но вам придется все время конкурировать за процессорное время.
• %wa – iowait% — показатель количества времени, которое уходит на отсылку ваших процессов на невероятно медленные диски, неважно какое решение для хранения данных вы используете. Диски, даже SSD, сравнительно медленные. Добавление ОЗУ для увеличения буфера ядра может немного смягчить проблему. ОЗУ дешевле диска, если учесть, насколько молниеносно она работает по сравнению с ним.

Дополнительные команды

iostat
Если вы столкнулись с высокими значениями параметров iowait или iosteal, можно с точностью отследить, какой диск является этому причиной, при помощи команды iostat. Запускается она таким образом: